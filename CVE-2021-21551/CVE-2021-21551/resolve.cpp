#include "resolve.h"

UINT64 resolve::convert(HMODULE hModule, UINT64 BaseAddress, UINT64 Usermode)
{
	Usermode -= reinterpret_cast<UINT64>(hModule);
	Usermode += BaseAddress;

	return Usermode;
}

bool resolve::BaseAddress(const wchar_t* szDriverName, PUINT64 BaseAddress)
{
	const int nSize = 1024 * 2;

	LPVOID lpImageBase[nSize] = { 0 };
	DWORD cbNeeded = 0;

	if (EnumDeviceDrivers(lpImageBase, nSize, &cbNeeded) &&
		cbNeeded < sizeof(lpImageBase))
	{
		wchar_t szDriver[nSize] = { 0 };
		int drivers = cbNeeded / sizeof(lpImageBase[0]);

		for (int i = 0; i < drivers; i++)
		{
			if (GetDeviceDriverBaseName(
				lpImageBase[i],
				szDriver,
				sizeof(szDriver) / sizeof(szDriver[0])
			))
			{
				if (wcscmp(szDriver, szDriverName) == 0)
				{
					*BaseAddress = reinterpret_cast<UINT64>(lpImageBase[i]);
					return true;
				}
			}
		}
	}

	return false;
}

bool resolve::MmPteBase(UINT64 BaseAddress, PUINT64 Result)
{
	HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");
	if (hModule == NULL)
	{
		return false;
	}

	FARPROC MmReturnChargesToLockPagedPool = GetProcAddress(
		hModule,
		"MmReturnChargesToLockPagedPool"
	);
	if (MmReturnChargesToLockPagedPool == NULL)
	{
		return false;
	}

	UINT64 mask = 0xffffffff00000000;
	UINT8 value = 0;
	UINT8 i = 0;
	bool bFound = false;

	do
	{
		value = *reinterpret_cast<PUINT8>(
			reinterpret_cast<PUINT8>(MmReturnChargesToLockPagedPool) + i 
			);
		if (value == 0xe8)
		{
			UINT32 offset = *reinterpret_cast<PUINT32>(
				reinterpret_cast<PUINT8>(MmReturnChargesToLockPagedPool) + i + 1
				);
			offset += 5;

			mask |= offset;

			bFound = true;

			break;
		}
		i++;
	} while (value != 0xc3);

	if (!bFound)
	{
		FreeLibrary(hModule);
		hModule = nullptr;

		return false;
	}

	*Result = convert(
		hModule,
		BaseAddress,
		reinterpret_cast<UINT64>(MmReturnChargesToLockPagedPool) + i + mask
	);

	*Result += 0x13;

	FreeLibrary(hModule);
	hModule = nullptr;

	return true;
}

bool resolve::PspCreateProcessNotifyRoutineasdf()
{
	HMODULE hModule = LoadLibrary(L"ntoskrnl.exe");
	if (hModule == NULL)
	{
		return false;
	}

	FARPROC MmReturnChargesToLockPagedPool = GetProcAddress(
		hModule,
		"MmReturnChargesToLockPagedPool"
	);
	if (MmReturnChargesToLockPagedPool == NULL)
	{
		return false;
	}

	FARPROC PsSetCreateProcessNotifyRoutine = GetProcAddress(
		hModule,
		"PsSetCreateProcessNotifyRoutine"
	);
	if (PsSetCreateProcessNotifyRoutine == NULL)
	{
		return false;
	}

	UINT8 i = 0;
	UINT8 value = 0;
	UINT32 offset = 0;
	UINT32 RoutineOffset = 0;
	bool bFound = false;

	do
	{
		value = *reinterpret_cast<PUINT8>(
			reinterpret_cast<PUINT8>(PsSetCreateProcessNotifyRoutine) + i
			);
		if (value == 0xe8)
		{
			offset = *reinterpret_cast<PUINT32>(
				reinterpret_cast<PUINT8>(PsSetCreateProcessNotifyRoutine) + i + 1
				);
			offset += 5;

			bFound = true;
			break;
		}
	} while (value != 0xc3);

	if (!bFound)
	{
		FreeLibrary(hModule);
		hModule = nullptr;
		return false;
	}

	///
	/// It is the first lea r13 that loads what I want
	/// nt!PspSetCreateProcessNotifyRoutine+0x60:
	/// fffff807`589881e8 33db xor ebx, ebx
	/// fffff807`589881ea 4c8d2d2f435600  lea     r13, [nt!PspCreateProcessNotifyRoutine(fffff807`58eec520)]
	/// 
	UINT8 InstructionSig[] = { 0x4c, 0x8d, 0x2d };

	UINT64 InstructionAddy = reinterpret_cast<UINT64>(PsSetCreateProcessNotifyRoutine);
	InstructionAddy += i;
	InstructionAddy += offset;

	do
	{
		size_t insts = RtlCompareMemory(
			reinterpret_cast<PVOID>(InstructionAddy),
			InstructionSig,
			sizeof(InstructionSig)
		);
		if (insts == sizeof(InstructionSig))
		{
			break;
		}
		InstructionAddy++;
	} while (bFound);

	InstructionAddy += 3;

	RtlCopyMemory(&RoutineOffset, (const PVOID)InstructionAddy, sizeof(RoutineOffset));
	RoutineOffset += 4;

	FreeLibrary(hModule);
	hModule = nullptr;

	return true;
}
