#pragma once
#include "common.h"
#include "globals.h"

#include <ntddk.h>

namespace CngDetour
{
	/// <summary>
	/// Dynamically resolves the vulnerable CNG function to place an inline hook.
	/// </summary>
	/// <param name="CfgPropertyAddress"></param>
	/// <returns>NTSTATUS</returns>
	inline NTSTATUS resolveCfgAdtpFormatPropertyBlock(PVOID* CfgPropertyAddress)
	{
		for (uint32_t i = 0; i < g_HijackedDriver->DriverSize; i++)
		{
			if (memcmp(
				static_cast<PUCHAR>(g_HijackedDriver->DriverStart) + i,
				CfgAdtpFormatPropertyBlockSignature,
				sizeof(CfgAdtpFormatPropertyBlockSignature)) == 0)
			{
				*CfgPropertyAddress = static_cast<PUCHAR>(g_HijackedDriver->DriverStart) + i;
				return STATUS_SUCCESS;
			}
		}
		return STATUS_NOT_FOUND;
	}

	/// <summary>
	/// Writes to the memory of an address space. This uses MDL's to map an address and 
	/// be able to write to it without janky stuff like modifying cr0.wp. 
	/// </summary>
	/// <param name="targetAddress"></param>
	/// <param name="buffer"></param>
	/// <param name="length"></param>
	/// <returns>NTSTATUS</returns>
	inline NTSTATUS writeToMemory(PVOID targetAddress, uint8_t* buffer, uint32_t length)
	{
		PMDL pmdl = IoAllocateMdl(targetAddress, length, FALSE, FALSE, NULL);
		if (pmdl != NULL)
		{
			__try
			{
				MmProbeAndLockPages(pmdl, KernelMode, IoModifyAccess);
			}
			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				IoFreeMdl(pmdl);
				return STATUS_ACCESS_VIOLATION;
			}

			PVOID mappedPage = MmMapLockedPagesSpecifyCache(pmdl, KernelMode, MmNonCached, NULL, FALSE, NormalPagePriority);
			if (mappedPage != NULL)
			{
				RtlCopyMemory(mappedPage, buffer, sizeof(__stub_detour));

				MmUnmapLockedPages(mappedPage, pmdl);
				MmUnlockPages(pmdl);
				IoFreeMdl(pmdl);

				return STATUS_SUCCESS;
			}
			else
			{
				MmUnlockPages(pmdl);
				IoFreeMdl(pmdl);
				return STATUS_UNSUCCESSFUL;
			}
		}
		return STATUS_UNSUCCESSFUL;
	}

	/// <summary>
	/// Places the inline hook at the start of CfgAdtpFormatPropertyBlock. 
	/// </summary>
	/// <param name="targetAddress"></param>
	/// <returns></returns>
	inline NTSTATUS detourFunction(PVOID targetAddress)
	{
		PVOID detouredFunctionAddress = __detoured_function;
		NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

		uint8_t* trampoline = (uint8_t*)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(__stub_detour), CNGUARDTAG);
		if (trampoline != NULL)
		{
			RtlSecureZeroMemory(trampoline, sizeof(__stub_detour));

			RtlCopyMemory(trampoline, __stub_detour, sizeof(__stub_detour));
			RtlCopyMemory(trampoline + 2, &detouredFunctionAddress, sizeof(detouredFunctionAddress));

			Status = writeToMemory(targetAddress, trampoline, sizeof(__stub_detour));
			if (!NT_SUCCESS(Status))
			{
				ExFreePoolWithTag(trampoline, CNGUARDTAG);
				return Status;
			}
			else
			{
				ExFreePoolWithTag(trampoline, CNGUARDTAG);
			}
		}
		return Status;
	}

	/// <summary>
	/// Restores the inline hook placed at the beginning of CfgAdtpFormatPropertyBlock.
	/// </summary>
	/// <param name="targetAddress"></param>
	/// <returns></returns>
	inline NTSTATUS restoreFunction(PVOID targetAddress)
	{
		NTSTATUS Status = STATUS_SUCCESS;

		uint8_t* restoreStub = (uint8_t*)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(__stub_detour), CNGUARDTAG);
		if (restoreStub != NULL)
		{
			RtlSecureZeroMemory(restoreStub, sizeof(__stub_detour));

			RtlCopyMemory(restoreStub, CfgAdtpFormatPropertyBlockSignature, sizeof(__stub_detour));

			Status = writeToMemory(targetAddress, restoreStub, sizeof(__stub_detour));
			if (!NT_SUCCESS(Status))
			{
				ExFreePoolWithTag(restoreStub, CNGUARDTAG);
				return Status;
			}
			else
			{
				ExFreePoolWithTag(restoreStub, CNGUARDTAG);
			}
		}
		return Status;
	}
}

